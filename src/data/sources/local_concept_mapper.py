# === MODULE PURPOSE ===
# Maps stocks to/from concept boards using LOCAL pre-built data files.
# Zero runtime API calls — all data comes from:
#   - data/sectors.json        (THS concept board names)
#   - data/board_constituents.json  (board → constituent stocks)
#
# Replaces ConceptMapper (iFinD iwencai) and AkshareConceptMapper (东财 API).

# === DEPENDENCIES ===
# - board_filter: Reuses junk board filtering
# - data/sectors.json: Board name list (maintained in repo)
# - data/board_constituents.json: Board constituents (generated by
#     scripts/download_board_constituents.py)

# === KEY CONCEPTS ===
# - Forward index: board_name → [(stock_code, stock_name), ...]
# - Reverse index: stock_code → [board_name, ...] (built at load time)
# - Same interface as ConceptMapper so MomentumSectorScanner works unchanged

from __future__ import annotations

import json
import logging
from pathlib import Path

from src.strategy.filters.board_filter import filter_boards

logger = logging.getLogger(__name__)

_PROJECT_ROOT = Path(__file__).resolve().parent.parent.parent.parent
# Docker: /app/data is a volume mount, static files go to /app/bundled_data
_BUNDLED_DIR = _PROJECT_ROOT / "bundled_data"
_DATA_DIR = _BUNDLED_DIR if _BUNDLED_DIR.exists() else _PROJECT_ROOT / "data"
_SECTORS_PATH = _DATA_DIR / "sectors.json"
_CONSTITUENTS_PATH = _DATA_DIR / "board_constituents.json"


class LocalConceptMapper:
    """
    Maps stocks to/from concept boards via local JSON files.

    Same interface as ConceptMapper / AkshareConceptMapper so
    MomentumSectorScanner works without modification.

    Data files:
        data/sectors.json            — THS concept board names (repo)
        data/board_constituents.json — board → stocks (generated offline)

    Usage:
        mapper = LocalConceptMapper()
        concepts = await mapper.get_stock_concepts("600519")
        stocks = await mapper.get_board_stocks("白酒")
    """

    def __init__(self) -> None:
        # Forward: board_name → [(code, name), ...]
        self._board_stocks: dict[str, list[tuple[str, str]]] = {}
        # Reverse: stock_code → [board_name, ...]  (junk boards filtered)
        self._stock_boards: dict[str, list[str]] = {}
        # Valid board names from sectors.json
        self._valid_boards: set[str] = set()

        self._loaded = False

    def _ensure_loaded(self) -> None:
        """Load data files on first access."""
        if self._loaded:
            return

        # Load valid board names from sectors.json
        if _SECTORS_PATH.exists():
            with open(_SECTORS_PATH, encoding="utf-8") as f:
                sectors = json.load(f)
            for item in sectors.get("concept", []):
                self._valid_boards.add(item["name"])
            logger.info(
                "LocalConceptMapper: loaded %d board names from sectors.json",
                len(self._valid_boards),
            )
        else:
            logger.warning(f"LocalConceptMapper: sectors.json not found at {_SECTORS_PATH}")

        # Load board constituents
        if _CONSTITUENTS_PATH.exists():
            with open(_CONSTITUENTS_PATH, encoding="utf-8") as f:
                raw: dict[str, list[list[str]]] = json.load(f)

            for board_name, stocks in raw.items():
                tuples = [(s[0], s[1] if len(s) > 1 else "") for s in stocks if s]
                self._board_stocks[board_name] = tuples

            logger.info(
                f"LocalConceptMapper: loaded {len(self._board_stocks)} boards, "
                f"{sum(len(v) for v in self._board_stocks.values())} total stock entries"
            )
        else:
            raise FileNotFoundError(
                f"board_constituents.json not found at {_CONSTITUENTS_PATH}. "
                f"Run: uv run python scripts/download_board_constituents.py"
            )

        # Halt if any board has >2000 constituents — likely corrupt data
        # (iwencai returning full market). Largest legitimate board is
        # ~1200 (机器人概念, 人工智能, etc.)
        # Trading safety: corrupt data → HALT, never silently drop.
        _MAX_BOARD_SIZE = 2000
        oversized = [
            (b, len(s)) for b, s in self._board_stocks.items() if len(s) > _MAX_BOARD_SIZE
        ]
        if oversized:
            details = ", ".join(f"'{b}' ({n} stocks)" for b, n in oversized)
            raise RuntimeError(
                f"LocalConceptMapper: corrupt board_constituents.json — "
                f"boards with >{_MAX_BOARD_SIZE} constituents detected: {details}. "
                f"Re-run: uv run python scripts/download_board_constituents.py"
            )

        # Build reverse index: stock → boards (with junk filtering)
        reverse: dict[str, list[str]] = {}
        for board_name, members in self._board_stocks.items():
            for code, _name in members:
                if code not in reverse:
                    reverse[code] = []
                reverse[code].append(board_name)

        # Apply junk board filter to reverse index
        for code, boards in reverse.items():
            self._stock_boards[code] = filter_boards(boards)

        self._loaded = True

    def clear_cache(self) -> None:
        """No-op for interface compatibility. Local data doesn't need clearing."""
        pass

    async def get_stock_concepts(self, stock_code: str) -> list[str]:
        """Get concept boards that a stock belongs to (from local data)."""
        self._ensure_loaded()
        bare = _normalize_code(stock_code)
        if not bare:
            return []
        return self._stock_boards.get(bare, [])

    async def batch_get_stock_concepts(self, stock_codes: list[str]) -> dict[str, list[str]]:
        """Batch reverse lookup (instant, all local)."""
        self._ensure_loaded()
        results: dict[str, list[str]] = {}
        for code in stock_codes:
            bare = _normalize_code(code)
            if bare:
                results[bare] = self._stock_boards.get(bare, [])
        return results

    async def get_board_stocks(self, board_name: str) -> list[tuple[str, str]]:
        """Get all constituent stocks of a concept board (from local data)."""
        self._ensure_loaded()
        return self._board_stocks.get(board_name, [])

    async def batch_get_board_stocks(
        self, board_names: list[str]
    ) -> dict[str, list[tuple[str, str]]]:
        """Batch get constituent stocks for multiple boards (instant, all local)."""
        self._ensure_loaded()
        return {name: self._board_stocks.get(name, []) for name in board_names}


def _normalize_code(stock_code: str) -> str:
    """Normalize stock code to bare 6-digit format."""
    if not stock_code:
        return ""
    code = str(stock_code).strip()
    for suffix in (".SZ", ".SH", ".BJ", ".sz", ".sh", ".bj"):
        if code.endswith(suffix):
            code = code[: -len(suffix)]
            break
    if len(code) == 6 and code.isdigit():
        return code
    return ""
