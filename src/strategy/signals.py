# === MODULE PURPOSE ===
# Trading signal data models.
# Defines the structure for signals generated by strategies.

# === KEY CONCEPTS ===
# - SignalType: BUY/SELL/HOLD action types
# - TradingSignal: Complete signal with metadata
# - Signals flow from Strategy -> Trading module

from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Any


class SignalType(Enum):
    """Trading signal types."""

    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"


class OrderType(Enum):
    """Order execution types."""

    MARKET = "market"  # Execute at market price
    LIMIT = "limit"  # Execute at specified price or better


class SignalPriority(Enum):
    """Signal urgency levels."""

    LOW = "low"  # Can wait, opportunistic
    NORMAL = "normal"  # Standard execution
    HIGH = "high"  # Execute soon
    URGENT = "urgent"  # Execute immediately


@dataclass
class TradingSignal:
    """
    Trading signal generated by a strategy.

    A signal represents a trading recommendation from a strategy
    to the trading module. It includes all information needed
    to execute or evaluate the trade.

    Data Flow:
        Strategy.generate_signals() -> TradingSignal -> Trading Module

    Fields:
        signal_type: BUY, SELL, or HOLD action
        stock_code: Stock identifier (e.g., "000001.SZ")
        quantity: Number of shares to trade
        strategy_name: Source strategy identifier
        price: Target price (None for market orders)
        order_type: MARKET or LIMIT order
        confidence: Strategy confidence (0.0-1.0)
        priority: Execution urgency
        reason: Human-readable explanation
        stop_loss: Stop loss price (optional)
        take_profit: Take profit price (optional)
        valid_until: Signal expiration time (optional)
        metadata: Additional strategy-specific data
    """

    signal_type: SignalType
    stock_code: str
    quantity: int
    strategy_name: str

    # Optional price target (None = market order)
    price: float | None = None
    order_type: OrderType = OrderType.MARKET

    # Signal quality indicators
    confidence: float = 0.5  # 0.0 to 1.0
    priority: SignalPriority = SignalPriority.NORMAL

    # Explanation
    reason: str = ""

    # Risk management
    stop_loss: float | None = None
    take_profit: float | None = None

    # Validity
    valid_until: datetime | None = None

    # Timestamps
    created_at: datetime = field(default_factory=datetime.now)

    # Strategy-specific metadata
    metadata: dict[str, Any] = field(default_factory=dict)

    def __post_init__(self):
        """Validate signal data."""
        if self.confidence < 0.0 or self.confidence > 1.0:
            raise ValueError(f"Confidence must be 0.0-1.0, got {self.confidence}")

        if self.quantity < 0:
            raise ValueError(f"Quantity must be non-negative, got {self.quantity}")

        if self.signal_type == SignalType.HOLD and self.quantity > 0:
            # HOLD signals shouldn't have quantity
            self.quantity = 0

    def is_valid(self, now: datetime | None = None) -> bool:
        """
        Check if signal is still valid.

        Args:
            now: Current time for comparison.

        Returns:
            True if signal has not expired.
        """
        if self.valid_until is None:
            return True

        if now is None:
            now = datetime.now()

        return now < self.valid_until

    def is_actionable(self) -> bool:
        """
        Check if signal requires action.

        Returns:
            True if signal is BUY or SELL with quantity > 0.
        """
        return self.signal_type != SignalType.HOLD and self.quantity > 0

    def to_dict(self) -> dict[str, Any]:
        """Convert signal to dictionary for serialization."""
        return {
            "signal_type": self.signal_type.value,
            "stock_code": self.stock_code,
            "quantity": self.quantity,
            "strategy_name": self.strategy_name,
            "price": self.price,
            "order_type": self.order_type.value,
            "confidence": self.confidence,
            "priority": self.priority.value,
            "reason": self.reason,
            "stop_loss": self.stop_loss,
            "take_profit": self.take_profit,
            "valid_until": self.valid_until.isoformat() if self.valid_until else None,
            "created_at": self.created_at.isoformat(),
            "metadata": self.metadata,
        }

    @classmethod
    def from_dict(cls, data: dict[str, Any]) -> "TradingSignal":
        """Create signal from dictionary."""
        return cls(
            signal_type=SignalType(data["signal_type"]),
            stock_code=data["stock_code"],
            quantity=data["quantity"],
            strategy_name=data["strategy_name"],
            price=data.get("price"),
            order_type=OrderType(data.get("order_type", "market")),
            confidence=data.get("confidence", 0.5),
            priority=SignalPriority(data.get("priority", "normal")),
            reason=data.get("reason", ""),
            stop_loss=data.get("stop_loss"),
            take_profit=data.get("take_profit"),
            valid_until=(
                datetime.fromisoformat(data["valid_until"])
                if data.get("valid_until")
                else None
            ),
            created_at=(
                datetime.fromisoformat(data["created_at"])
                if data.get("created_at")
                else datetime.now()
            ),
            metadata=data.get("metadata", {}),
        )

    def __str__(self) -> str:
        """Human-readable representation."""
        price_str = f"@{self.price}" if self.price else "@MARKET"
        return (
            f"{self.signal_type.value.upper()} {self.stock_code} "
            f"x{self.quantity} {price_str} "
            f"(conf={self.confidence:.0%}, from={self.strategy_name})"
        )
